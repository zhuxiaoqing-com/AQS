刚刚我们通过一个实战案例，讲解了如何依赖注入来提高代码的可测试性，以及编写单元测试中最复杂的一部分内容：
如何通过 mock、二次封装等方式解依赖外部服务。
现在，我们再来总结一下，有哪些经典的、常见的测试性不好的代码，也就是我们常说的 Anti-Patterns;

1、未决行为
    所谓未决行为逻辑就是，代码的输出是随机或者说不确定的，比如时间、随机数有关的代码。

2、全局变量
    全局变量是一种面向过程的编程风格

3、静态方法
    静态方法是一种面向过程的编程风格。
    在代码中调用静态方法，有时候会导致代码不易测试。
    主要原因是静态方法也很难 mock。
    但是这个要分情况来看。
    只有在这个静态方法执行耗时太长、依赖外部资源、逻辑复杂、行为未决的情况下，
    我们才需要在单元测试中 mock 这个静态方法。

4、复杂继承
    我们前面提到，相比组合关系，继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。
    实际上，继承关系也更加难测试。

5、高耦合代码
    如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，
    可能需要 mock 这十几个依赖的对象。不管是从代码设计的角度来说，还是从编写单元测试的角度来说，这都是不合理的。













Transaction 类的单元测试

我们设计了下面6个测试用例

1、正常情况下，交易执行成功，回填用于对账(交易与钱包的交易流水)用的 walletTransactionId,
    交易状态设置为 EXECUTED, 函数返回 true;

2、buyerId、sellerId 为 null， amount 小于 0，返回 InvalidTransactionException;

3、交易已过期(createTimestamp 超过 14 天)，交易状态设置为 EXPIRED， 返回 false;

4、交易已经执行了 (status == EXECUTED), 不再重复执行转钱逻辑，返回 true;

5、钱包(WalletRpcService) 转钱失败，交易状态设置为 FAILED，函数返回 false;

6、交易正在执行着，不会被重复执行，函数直接返回 false;















