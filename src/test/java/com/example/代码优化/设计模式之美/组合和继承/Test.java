package com.example.代码优化.设计模式之美.组合和继承;

/**
 * @Auther: zhuxiaoqing
 * @Date: 2020/5/14 19:56
 * @Description:
 */
public class Test {
	/**
	 * 我们可以利用组合 composition 、接口、 委托 delegation 三个技术手段来解决继承层次过深、继承关系过于复杂的问题
	 */


	/**
	 * 案例：
	 *
	 * 我们设计一个关于鸟的类。我们将"鸟类"这样一个抽象的事物概念，定义为一个抽象类
	 * public class AbstractBird{
	 * 	fly(); // 飞
	 * }
	 *
	 * 我们现在要添加一个具体的鸟 鸵鸟;
	 * 但是鸵鸟又不会飞;
	 * 但是又必须要实现 fly(); 方法;
	 * 我们可以用 抛异常的方法 让鸵鸟不能飞;
	 * 但是这个接口设计的就有问题了; 因为你暴露的接口并不是所有子类都有用的；
	 * 这对使用该接口的其他人,会造成误解;有可能会误用这个 fly() 这接口
	 *
	 * public class Ostrich extends AbstractBird {
	 *     // 鸵鸟
	 *     public void fly(){
	 *         throws new RuntimeException("鸵鸟不会飞");
	 *     }
	 * }
	 *
	 * 当然你也可以用子抽象类;
	 *
	 * 在写两个子抽象类
	 *
	 * class abstractFlyableBird extends AbstractBird {}  // 会飞的鸟
	 * class abstractUnFlyableBird extends AbstractBird {} // 不会飞的鸟
	 *
	 * 但是如果你又要 有会叫的 不会叫的鸟 呢？
	 * 这个继承层次就非常深了  继承关系会变得过于复杂
	 *
	 * 下面看我们怎么用组合来解决这个问题
	 *
	 * 我们前面讲到接口的时候说过, 接口表示具有某种行为特性。
	 * 针对"会飞"这样一个行为特性,我们可以定义一个 Flyable 接口, 只让会飞的鸟去实现这个接口。
	 * 对于会叫、会下蛋这些行为特性，我们可以类似的定义 Tweetable 接口、 EggLayable 接口。
	 *
	 * 不过我们知道 接口只声明方法，不定义实现。
	 * 也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑都是一样的，这就会导致代码重复的问题。
	 * 那这个问题又该如何解决呢？
	 *
	 * 我们可以针对三个接口再定义三个实现类，它们分别是：
	 * 实现了 fly()方法的 flyAbility 类、
	 * 实现了 tweet() 方法的 TweetAbility 类、
	 * 实现了 layEgg() 方法的 EggLayAbility 类。
	 *
	 * 然后通过组合和委托技术来消除代码重复。
	 *
	 * 新想法： 这里因为java8 接口提供了 default 方法; 可以直接将重复的方法写在接口中;
	 * 	如果有多种 fly()的实现呢？ 那就哪个鸟需要不同的实现 就覆写这个 default 方法
	 *
	 *
	 *
	 * 组合和继承的优缺点
	 *
	 * 尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。
	 * 从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。
	 * 这也就意味着，我们要定义更多的类和接口。
	 * 这些类和接口的增多也就或多或少的增加代码的复杂程度和维护成本；
	 *
	 *
	 * 如果类之间的继承结构稳定(不会轻易改变)，继承层次比较浅(比如最多两层继承关系)，继承关系不复杂，
	 * 我们就可以大胆的使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来代替继承。
	 *
	 */

}















